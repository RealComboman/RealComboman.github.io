<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=0.95"><title>Colmuns</title><link rel="shortcut icon" href="combo.ico">
<style>
body {display: flex; justify-content: center; align-items: center;height: 100vh; background-color: #222; margin: 0;}
canvas { background-color: black; border: 2px solid white;}
#scores { color: yellow; font-family: Times, serif; border-color: gray; border-style: solid; border-width: 2px; text-align: center;}
</style></head>
<body><div><canvas id="game"></canvas>
<div id="scores"><H2><span id="gameOver"></span><br>₪₪₪₪₪₪₪₪₪₪₪₪</H2><H3><span id="scoreDsp"></span></H3></div></div>
<script>
const canvas = document.getElementById('game');
const context = canvas.getContext('2d');   
const boardRows     = 13;   // board rows
const boardColumns  = 7;    // board column
const tileSize      = 40; //32;   // tile size, in pixels 
const columnHeight  = 3     // column height
const board         = [];   // game board 
let itemsToRemove=[];
let dropInterval    = 500;  // drop interval, in milliseconds
let score = 0;
let highScore = localStorage.getItem("myHighScore");
let freeze = 0;
let checkFallingBlocks = false;
// size and scale canvas according to tile and board size
canvas.width = boardColumns * tileSize;
canvas.height = boardRows * tileSize;
context.scale(tileSize, tileSize);
// array with all possible block colors
const blockColors = ['#00FFFF', '#FFFF00', '#800080', '#00A000', '#A00000', '#0000BB', '#FF7711'] //'#F0A000']                          
let randomColumn = getRandomColumn();
let columnPosition = {row  : -2, column  : 3}; //column starts two tiles outside playable area
let dropTimer = 0;
let lastTime = 0; // time since previous frame
let touchstartX = 0;
let touchendX = 0;
const touchmin = 5;
const el = document.getElementById("game");
el.addEventListener('touchstart', e => {touchstartX = e.changedTouches[0].screenX})    
el.addEventListener('touchend', e => {touchendX = e.changedTouches[0].screenX; checkDirection()})
initializeBoard();// initialize the board
alert("K̲e̲y̲b̲o̲a̲r̲d̲\n⇦ \tMove Left\n⇨ \tMove Right\n⇧ \tRotate Colours\n⇩ \tDrop\n\nT̲o̲u̲c̲h̲_S̲c̲r̲e̲e̲n̲\nSwipe Left/Right\nTap to Rotate Colours");
update();// call update method

function checkDirection() {
  if (touchendX < touchstartX-touchmin) shiftLeft();
  else if (touchendX > touchstartX+touchmin) shiftRight();
  else shiftColumn(); //tap
  dropTimer=0; //reset timer
}

// function to initialize the board, setting all values to zero
function initializeBoard() {
    for (let i = 0; i < boardRows; i ++) {
        board[i] = [];
        for (let j = 0; j < boardColumns; j ++) {board[i][j] = 0;} 
    }
}

// game loop
// time: amount of milliseconds passed since script beginning
function update(time = 0) {
    if (freeze) {return;}
    const deltaTime = time - lastTime; // elapsed time since previous time
    lastTime = time;
	 gameOver.innerHTML="<⋄ㄥ∨ʍꈤ𐌔";
	if(score>highScore) {highScore = score; localStorage.setItem("myHighScore", highScore);}
	scoreDsp.innerHTML = "Score: "+score+" — High Score: "+highScore;
    dropTimer += deltaTime;
	//removeBlocks ();
    // if drop timer is bigger than drop interval, it's time to make the column drop
    if (dropTimer > dropInterval) {
        dropTimer=0;// reset drop timer
		if(checkFallingBlocks) {
			fallBlocks();}
		else {
			columnPosition.row++;// move column down
			if (isColumnColliding()) {// is column colliding?
				columnPosition.row--;// move column up
				mergeColumn();// merge columns
				clearBlocks();// clear lines if needed
				randomColumn = getRandomColumn();// place a new column
				columnPosition = { row : -2, column : 3};
				if (isColumnColliding()) {// is newborn column already colliding?
					GameOver();// GAME OVER!! (just clear the board in this case)
				}
			}
		}
    }
    drawBoard(); drawColumn();// draw the falling column
    requestAnimationFrame(update);// request new frame and call update function (this one)
}

function GameOver(){
gameOver.innerHTML = "GᗩᗰE OᐯEᖇ";
freeze=1;
}

// it's just an array with three random blocks
function getRandomColumn() {
    const column = [];
    for (let i = 0; i < columnHeight; i++) {
        column.push(Math.floor(Math.random() * blockColors.length));
    } 
    return column;
}

// function to shift a column
function shiftColumn() {
    const head = randomColumn[0];
    for (let i = 1; i < columnHeight; i++) {randomColumn[i - 1] = randomColumn[i];}
    randomColumn[columnHeight - 1] = head;
}

// functions to merge a column with game board
function mergeColumn() {
    for (let i = 0; i < columnHeight; i++) {
        if (columnPosition.row + i >= 0) {board[columnPosition.row + i][columnPosition.column] = randomColumn[i] + 1;}
    }  
}

// function to check if a column is colliding
function isColumnColliding() {
    for (let i = 0; i < columnHeight; i++) {
        const row = columnPosition.row + i;
        if (row >= 0 && (columnPosition.column < 0 || row >= boardRows || columnPosition.column >= boardColumns || board[row][columnPosition.column] != 0)) {
            return true;
        }
    }
    return false;
}

// function to clear blocks and make above blocks fall down
function clearBlocks() {
    itemsToRemove = [];
	let combos=0;
    for (let i = 0; i < boardRows; i++) {
        for (let j = 0; j < boardColumns; j++) {
            if (board[i][j] != 0) {
                let value = board[i][j];
                let combo = 1; // vertical
                while (j + combo < boardColumns && board[i][j + combo] == value) {combo ++;}
                if (combo >= 3) {
                    for (let k = 0; k < combo; k++) { itemsToRemove.push({row     : i, column  : j + k }); score += 10;}
					combos++;
                }
                combo = 1; // horizontal
                while (i + combo < boardRows && board[i + combo][j] == value) {combo++;}
                if (combo >= 3) {
                    for (let k = 0; k < combo; k++) {itemsToRemove.push({ row     : i + k, column  : j }); score += 10;}
					combos++;
                }
                combo = 1; // diagonal 1 
                while (i + combo < boardRows && j + combo < boardColumns  && board[i + combo][j + combo] == value) {combo++;}
                if (combo >= 3) {
                    for (let k = 0; k < combo; k++) { itemsToRemove.push({ row     : i + k, column  : j + k }); score += 10;}
					combos++;
                }
                combo = 1;  // diagonal 2
                while (i - combo > 0 && j + combo < boardColumns  && board[i - combo][j + combo] == value) {combo ++;}
                if (combo >= 3) {
                    for (let k = 0; k < combo; k++) {itemsToRemove.push({row     : i - k, column  : j + k}); score += 10;}
					combos++;
                }
            }
        }
    }
    if (itemsToRemove.length > 0) {// do we have items to remove?
        // remove them
        for (let i = 0; i < itemsToRemove.length; i++) {
            board[itemsToRemove[i].row][itemsToRemove[i].column] = 0;
        } 
		if(combos<2) {score += 10;} else {score += combos*50;}
		drawBoard();
		delay(dropInterval/2);
		checkFallingBlocks = true;
    }   else { checkFallingBlocks = false;}    
}
 
function fallBlocks() {
        while (checkFallingBlocks)  {
            checkFallingBlocks = false;
            for (let i = boardRows - 1; i > 0; i--) {
                for (let j = 0; j < boardColumns; j++) {
                    if (board[i][j] == 0 && board[i - 1][j] != 0) {
                        board[i][j] = board[i - 1][j];
                        board[i - 1][j] = 0;   
                        checkFallingBlocks = true;  
                    }
                }
            }
        }
		clearBlocks();
}

function delay(milliseconds) {
  const date = Date.now();
  let currentDate = null;
  do {
    currentDate = Date.now();
  } while (currentDate - date < milliseconds);
}

// function to draw the board
function drawBoard() {
    for (let i = 0; i < boardRows; i++) {
        for (let j = 0; j < boardColumns; j++) { 
            if (board[i][j] != 0) {
                context.fillStyle = blockColors[board[i][j] - 1];
				context.beginPath();context.arc(j+0.5,i+0.5,0.5,0,2*Math.PI);context.fill();
            }
            else {
                context.fillStyle = (i * boardColumns + j) % 2 == 0 ? '#000' : '#222';
                context.fillRect(j, i, 1, 1);
            }
        }
    }
}

// function to draw the column
function drawColumn() {
    for (let i = 0; i < columnHeight; i++) {
        context.fillStyle = blockColors[randomColumn[i]];
		//const grd = context.createRadialGradient(columnPosition.column+0.5,columnPosition.row+i+0.5,1,columnPosition.column+0.5,columnPosition.row+i+0.5,tileSize/2);
		//grd.addColorStop(1, randomColumn[i]);
		//grd.addColorStop(0, "white");
		//context.fillStyle = grd;
		context.beginPath();context.arc( columnPosition.column+0.5,columnPosition.row+i+0.5,0.5,0,2*Math.PI);context.fill();
        //context.fillRect(columnPosition.column, columnPosition.row + i, 1, 1);
    }
}

// keydown listener
document.addEventListener('keydown', (event) => {
    switch (event.key) {
        case 'ArrowLeft' :
			shiftLeft();
            break;
        case 'ArrowRight' :
			shiftRight();
            break;
        case 'ArrowUp' :
            shiftColumn();
            break;
        case 'ArrowDown' :
            dropInterval=50;
            break;
		case 'Enter' :
			if(freeze){freeze=0; score=0; initializeBoard(); update();}
			break;
    }
})  

function shiftRight(){columnPosition.column++; if (isColumnColliding()) {columnPosition.column--;}}

function shiftLeft(){columnPosition.column--; if (isColumnColliding()) {columnPosition.column++;}}

// keyup listener
document.addEventListener('keyup', (event) => {
    if (event.key == 'ArrowDown') {dropInterval = 500;}
});
</script></body></html>