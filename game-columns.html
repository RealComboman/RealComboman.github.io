<!DOCTYPE html><html lang="it"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Colmuns</title><link rel="shortcut icon" href="combo.ico">
<style>
body {display: flex; justify-content: center; align-items: center;height: 100vh; background-color: #222; margin: 0;}
canvas { background-color: black; border: 2px solid white;}
#scores { color: white; font-family: Times, serif; padding: 5px; border-color: gray; border-style: solid; border-width: 2px; justify-content: center;}
</style></head>
<body><div><canvas id="thegame"></canvas><br>
<div id="scores"><H2><span id="gameOver"> ∦ Columns ∦ </span></H2><H3>Score:  <span id="scoreDsp"></span></H3></div></div>
<script>
const canvas = document.getElementById('thegame');
const context = canvas.getContext('2d');   
const boardRows     = 13;   // board rows
const boardColumns  = 7;    // board column
const tileSize      = 40; //32;   // tile size, in pixels 
const columnHeight  = 3     // column height
const board         = [];   // game board 
let itemsToRemove=[];
let dropInterval    = 500;  // drop interval, in milliseconds
let score = 0;
let freeze = 0;
let checkFallingBlocks = false;
// size and scale canvas according to tile and board size
canvas.width = boardColumns * tileSize;
canvas.height = boardRows * tileSize;
context.scale(tileSize, tileSize);
// array with all possible block colors
const blockColors = ['#00FFFF', '#FFFF00', '#800080', '#00A000', '#A00000', '#0000BB', '#FF7711'] //'#F0A000']                          
let randomColumn = getRandomColumn();
let columnPosition = {row  : -2, column  : 3}; //column starts two tiles outside playable area
let dropTimer = 0;
let lastTime = 0; // time since previous frame
initializeBoard();// initialize the board
update();// call update method

// function to initialize the board, setting all values to zero
function initializeBoard() {
    for (let i = 0; i < boardRows; i ++) {
        board[i] = [];
        for (let j = 0; j < boardColumns; j ++) {board[i][j] = 0;} 
    }
}

// game loop
// time: amount of milliseconds passed since script beginning
function update(time = 0) {
    if (freeze) {return;}
    const deltaTime = time - lastTime; // elapsed time since previous time
    lastTime = time;
	scoreDsp.innerHTML = ""+score;
    dropTimer += deltaTime;
	//removeBlocks ();
    // if drop timer is bigger than drop interval, it's time to make the column drop
    if (dropTimer > dropInterval) {
        dropTimer = 0;// reset drop timer
		if(checkFallingBlocks) {
			fallBlocks();}
		else {
			columnPosition.row ++;// move column down
			if (isColumnColliding()) {// is column colliding?
				columnPosition.row --;// move column up
				mergeColumn();// merge columns
				clearBlocks();// clear lines if needed
				randomColumn = getRandomColumn();// place a new column
				columnPosition = { row     : -2, column  : 3};
				if (isColumnColliding()) {// is newborn column already colliding?
					GameOver();// GAME OVER!! (just clear the board in this case)
				}
			}
		}
    }
    drawBoard(); drawColumn();// draw the falling column
    requestAnimationFrame(update);// request new frame and call update function (this one)
}

function GameOver(){
gameOver.innerHTML = " GAME OVER ";
freeze=1;
}

// it's just an array with three random blocks
function getRandomColumn() {
    const column = [];
    for (let i = 0; i < columnHeight; i ++) {
        column.push(Math.floor(Math.random() * blockColors.length));
    } 
    return column;
}

// function to shift a column
function shiftColumn() {
    const head = randomColumn[0];
    for (let i = 1; i < columnHeight; i ++) {randomColumn[i - 1] = randomColumn[i];}
    randomColumn[columnHeight - 1] = head;
}

// functions to merge a column with game board
function mergeColumn() {
    for (let i = 0; i < columnHeight; i ++) {
        if (columnPosition.row + i >= 0) {board[columnPosition.row + i][columnPosition.column] = randomColumn[i] + 1;}
    }  
}

// function to check if a column is colliding
function isColumnColliding() {
    for (let i = 0; i < columnHeight; i ++) {
        const row = columnPosition.row + i;
        if (row >= 0 && (columnPosition.column < 0 || row >= boardRows || columnPosition.column >= boardColumns || board[row][columnPosition.column] != 0)) {
            return true;
        }
    }
    return false;
}

// function to clear blocks and make above blocks fall down
function clearBlocks() {
    itemsToRemove = [];
	let combos=0;
    for (let i = 0; i < boardRows; i ++) {
        for (let j = 0; j < boardColumns; j ++) {
            if (board[i][j] != 0) {
                let value = board[i][j];
                let combo = 1; // vertical
                while (j + combo < boardColumns && board[i][j + combo] == value) {combo ++;}
                if (combo >= 3) {
                    for (let k = 0; k < combo; k ++) { itemsToRemove.push({row     : i, column  : j + k }); score += 10;}
					combos++;
                }
                combo = 1; // horizontal
                while (i + combo < boardRows && board[i + combo][j] == value) {combo ++;}
                if (combo >= 3) {
                    for (let k = 0; k < combo; k ++) {itemsToRemove.push({ row     : i + k, column  : j }); score += 10;}
					combos++;
                }
                combo = 1; // diagonal 1 
                while (i + combo < boardRows && j + combo < boardColumns  && board[i + combo][j + combo] == value) {combo ++;}
                if (combo >= 3) {
                    for (let k = 0; k < combo; k ++) { itemsToRemove.push({ row     : i + k, column  : j + k }); score += 10;}
					combos++;
                }
                combo = 1;  // diagonal 2
                while (i - combo > 0 && j + combo < boardColumns  && board[i - combo][j + combo] == value) {combo ++;}
                if (combo >= 3) {
                    for (let k = 0; k < combo; k ++) {itemsToRemove.push({row     : i - k, column  : j + k}); score += 10;}
					combos++;
                }
            }
        }
    }
    if (itemsToRemove.length > 0) {// do we have items to remove?
        // remove them
        for (let i = 0; i < itemsToRemove.length; i ++) {
            board[itemsToRemove[i].row][itemsToRemove[i].column] = 0;
        } 
		if(combos<2) {score += 10;} else {score += combos*50;}
		drawBoard();
		delay(dropInterval/2);
		checkFallingBlocks = true;
    }   else { checkFallingBlocks = false;}    
}
 
function fallBlocks() {
        while (checkFallingBlocks)  {
            checkFallingBlocks = false;
            for (let i = boardRows - 1; i > 0; i --) {
                for (let j = 0; j < boardColumns; j ++) {
                    if (board[i][j] == 0 && board[i - 1][j] != 0) {
                        board[i][j] = board[i - 1][j];
                        board[i - 1][j] = 0;   
                        checkFallingBlocks = true;  
                    }
                }
            }
        }
		clearBlocks();
}

function delay(milliseconds) {
  const date = Date.now();
  let currentDate = null;
  do {
    currentDate = Date.now();
  } while (currentDate - date < milliseconds);
}

// function to draw the board
function drawBoard() {
    for (let i = 0; i < boardRows; i ++) {
        for (let j = 0; j < boardColumns; j ++) { 
            if (board[i][j] != 0) {
                context.fillStyle = blockColors[board[i][j] - 1];
				context.beginPath();context.arc(j+0.5,i+0.5,0.5,0,2*Math.PI);context.fill();
            }
            else {
                context.fillStyle = (i * boardColumns + j) % 2 == 0 ? '#000' : '#222';
                context.fillRect(j, i, 1, 1);
            }
        }
    }
}

// function to draw the column
function drawColumn() {
    for (let i = 0; i < columnHeight; i ++) {
<<<<<<< HEAD
        //context.fillStyle = blockColors[randomColumn[i]];
		const grd = context.createRadialGradient(columnPosition.column, columnPosition.row, columnPosition.column+1, columnPosition.row+1);
		grd.addColorStop(1, "black"); //randomColumn[i]);
		grd.addColorStop(0, "white");
		context.fillStyle = grd;
        //context.fillRect(columnPosition.column, columnPosition.row + i, 1, 1);
=======
        context.fillStyle = blockColors[randomColumn[i]];
		//const grd = context.createRadialGradient(columnPosition.column+0.5,columnPosition.row+i+0.5,1,columnPosition.column+0.5,columnPosition.row+i+0.5,tileSize/2);
		//grd.addColorStop(1, randomColumn[i]);
		//grd.addColorStop(0, "white");
		//context.fillStyle = grd;
>>>>>>> 0af810c044737fd29bc280b32dfb90bd4c62b6d7
		context.beginPath();context.arc( columnPosition.column+0.5,columnPosition.row+i+0.5,0.5,0,2*Math.PI);context.fill();
        //context.fillRect(columnPosition.column, columnPosition.row + i, 1, 1);
    }
}

// keydown listener
document.addEventListener('keydown', (event) => {
    switch (event.key) {
        case 'ArrowLeft' :
            columnPosition.column --;
            if (isColumnColliding()) {columnPosition.column ++;}
            break;
        case 'ArrowRight' :
            columnPosition.column ++;
            if (isColumnColliding()) {columnPosition.column --;}
            break;
        case 'ArrowUp' :
            shiftColumn();
            break;
        case 'ArrowDown' :
            dropInterval = 50;
            break;
		case 'Enter' :
			if(freeze){freeze=0; gameOver.innerHTML=" ∦ Columns ∦ "; score=0; initializeBoard(); update();}
			break;
    }
})  

// keyup listener
document.addEventListener('keyup', (event) => {
    if (event.key == 'ArrowDown') {dropInterval = 500;}
});
</script></body></html>